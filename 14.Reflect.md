# Reflect

### 1. 设计目的

- 将 Object 内部方法挂载到 Reflect 上

  ```js
  let obj = {}
  let newVal = ''
  Reflect.defineProperty(obj, 'name', {
      get() {
          return newVal
      },
      set(val) {
          console.log('set')
          newVal = val
      }
  })
  
  obj.name = 'xiaoming'
  console.log(obj.name) // set xiaoming
  ```
  
- 修改某些 Object 方法的返回结果，使其更合理

  ```js
  try {
      // success
      Object.defineProperty(target, property, attributes)
  } catch(e) {
      // failure
  }
  
  if (Reflect.defineProperty(target, property, attributes)) {
      // success
  } else {
      // failure
  }
  ```

- 让 Object 操作变为函数行为

  ```js
  console.log('assign' in Object) // true
  
  console.log(Reflect.has(Object, 'assign')) // true
  ```

- Reflect 与 Proxy 方法对应

### 2. 常用方法

- Reflect.apply

  ```js
  // ES5
  Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1
  
  Reflect.apply(Math.floor, undefined, [1.75]) // 1
  Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]) // 'hello'
  Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index // 4
  Reflect.apply(''.charAt, 'ponies', [3]) // i
  ```
  
- Reflect.construct

  相当于运行 ```new target(...args)```
  
  ```js
  const d = Reflect.construct(Date, [1776, 6, 4])
  console.log(d instanceof Date) // true
  console.log(d.getFullYear()) // 1776
  ```
  
- Reflect.defineProperty

  该静态方法基本等同于 Object.defineProperty，唯一不同的是返回 Boolean 值。
  
  ```js
  const student = {}
  Reflect.defineProperty(student, 'name', {
      value: 'Mike'
  })
  console.log(student.name) // Mike
  ```
  
- Reflect.deleteProperty

  该方法允许删除对象上的一个属性，并返回一个 Boolean 值表示该属性是否被成功删除，它几乎与非严格的 delete operator 相同。
  
  ```js
  let obj = {
      x: 1,
      y: 2
  }
  
  const returnDel = Reflect.deleteProperty(obj, 'x')
  console.log(returnDel) // true
  console.log(obj) // {y: 2}           
  ```
  
  ```js
  const arr = [1, 2, 3, 4, 5]
  const returnDelete = Reflect.deleteProperty(arr, '3')
  console.log(returnDelete) // true
  console.log(arr) // [1, 2, 3, empty, 5]
  ```
  
  ```js
  const returnDelete = Reflect.deleteProperty({ foo: 1 }, 'foo')
  console.log(returnDelete) // true
  ```
  
  ```js
  const returnDelete = Reflect.deleteProperty(Object.freeze({
      foo: 1
  }), 'foo')
  console.log(returnDelete) // false
  ```
  
- Reflect.get

  ```js
  const obj = {
      x: 1,
      y: 2
  }
  Reflect.get(obj, 'x') // 1
  ```
  
  ```js
  Reflect.get(['zero', 'one'], 1) // one
  ```
  
  ```js
  const x = {
      p: 1
  }
  let obj = new Proxy(x, {
      get(target, key, value) {
          return `${key}bar`
      }
  })
  Reflect.get(obj, 'foo') // 'foobar'
  ```
  
- Reflect.getOwnPropertyDescriptor

  ```js
  Reflect.getOwnPropertyDescriptor({
      x: 'hello'
  }, 'x') // {value: "hello", writable: true, enumerable: true, configurable: true}
  ```

  ```js
  Reflect.getOwnPropertyDescriptor({
      x: 'hello'
  }, 'y') // undefined
  ```

  ```js
  Reflect.getOwnPropertyDescriptor([], 'length')
  // {value: 0, writable: true, enumerable: false, configurable: false}
  ```

  ```js
  Reflect.getOwnPropertyDescriptor('foo', 0)
  // Uncaught TypeError: Reflect.getOwnPropertyDescriptor called on non-object
  
  Object.getOwnPropertyDescriptor('foo', 0)
  // {value: "f", writable: false, enumerable: true, configurable: false}
  ```

  






































